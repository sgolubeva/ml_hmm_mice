#!/usr/bin/env python

import numpy as np
import numpy.random as npr
import matplotlib.pyplot as plt
import ssm
import psytrack as psy
from ssm.util import find_permutation
import argparse
from collections import defaultdict 


def get_args():
    """This grabs arguments for setting total trials"""
    parser = argparse.ArgumentParser(description="global variables to set input file names")
    parser.add_argument("-n", "--ntrials", help="starting number of trials per session", required=True, type=int)
    #parser.add_argument("-e", "--end", help="ending number of trials", required=True, type=int)
    #parser.add_argument("-i", "--increment", help="increments of trials", required=True, type=int)
    parser.add_argument("-se", "--session", help="total number of sessions", required=True, type=int)
    parser.add_argument("-o", "--outfile", help="output file name", required=True, type=str)
    return parser.parse_args()

def generate_inputs(num_trials_per_sess, num_sess):

    """Takes number of trials per session and number of sessions generates inputs from stimulus 
    values and choices returns inputs"""

    print(f'generate ipts{num_trials_per_sess=}')
    inpts = np.ones((num_sess, num_trials_per_sess, input_dim))  # initialize inpts array
    # set stimulus values negative value correct choice is left [0], positive value correct choice 
    # is right[1]
    stim_vals = [-1, -0.5, -0.25, -0.125, -0.0625, 0, 0.0625, 0.125, 0.25, 0.5, 1]
    inpts[:, :, 0] = np.random.choice(stim_vals, (num_sess, num_trials_per_sess))  # generate random sequence of stimuli
    inpts = list(inpts)  # convert inpts to correct format
    return inpts


def make_standard_hmm(gen_weights, gen_log_trans_mat ):

    """Takes a matrix of weights and a matrix of state transition probabilities, returns an HMM model
     initialized with those matrices """
    
    true_glmhmm = ssm.HMM(num_states, obs_dim, input_dim, observations="input_driven_obs", 
                   observation_kwargs=dict(C=num_categories), transitions="standard")
    true_glmhmm.observations.params = gen_weights
    true_glmhmm.transitions.params = gen_log_trans_mat
    return true_glmhmm


def true_ll_model(num_trials_per_sess, num_sess):

    """"Takes number of trials per session and number of sessions returns log likelihood for the model
    initialized with standard weights and transition matrix""" 

    true_latents, true_choices = [], []
    for sess in range(num_sess):
        true_z, true_y = true_glmhmm.sample(num_trials_per_sess, input=inpts[sess])
        true_latents.append(true_z)
        true_choices.append(true_y)

    true_ll = true_glmhmm.log_probability(true_choices, inputs=inpts)
    return true_ll, true_latents, true_choices


def fit_glm_hmm(new_glmhmm):

    """Takes newly initialized hmm glm model (without standard transition matrix and weights) and 
    returns a fitted glm hmm"""

    fit_ll = new_glmhmm.fit(true_choices, inputs=inpts, method="em", num_iters=N_iters, tolerance=10**-4)

    return fit_ll


def convert_data_for_psytrack(inpts, true_choices):

    """"Takes inputs and choices generated by glmhmm. Converts iinput and choice data into appropriate
      formats for fitting psytrack, returns a dictionary with inputs and choices"""
    psy_data_dict = defaultdict(lambda: 'Not present')
    psy_data_dict['y'] = np.squeeze(true_choices[0]) # add choices data with removing the lowest dimension in choice data
    
    ins = inpts[0]
    psy_data_dict['inputs'] = {'inpt1': np.column_stack((ins[0:, 0], np.roll(ins[0:, 0], 1)))} # add input data into a dictionary of inputs
    psy_data_dict['inputs']['inpt1'][0,1] = psy_data_dict['inputs']['inpt1'][0,0]
    return(psy_data_dict)


def fit_psytrack(psy_track_data):
    """Takes      . Fits psytrack with choice and input data"""

    weights = {'bias': 1,
               'inpt1': 1} # generate a dictionary of weights for the model
    K = np.sum([weights[i] for i in weights.keys()]) # the total number of weights K in the model

    hyper= {'sigInit': 2**4.,      # Set to a single, large value for all weights. Will not be optimized further.
        'sigma': [2**-4.]*K,   # Each weight will have it's own sigma optimized, but all are initialized the same
        'sigDay': None}        # Indicates that session boundaries will be ignored in the optimization

    optList = ['sigma'] # optimize over sigma parameter 
    # fit psytrack
    hyp, evd, wMode, hess_info = psy.hyperOpt(psy_track_data, hyper, weights, optList)
    print('finished fitting psytrack')
    return hyp, evd, wMode, hess_info





if __name__ == "__main__":
    args = get_args()
    ntrials = args.ntrials #  number of trials
    #end = args.end  # Use the 'end' argument to specify the ending number of trials
    #inc = args.increment # increment number of trials
    num_sess = args.session # number of sessions
    out = args.outfile # name for plot figure


    # Set the parameters of the GLM-HMM
    num_states = 3        # number of discrete states
    obs_dim = 1           # number of observed dimensions
    num_categories = 2    # number of categories for output
    input_dim = 2         # input dimensions
    N_iters = 1000        # number of fit iterations 

    # set the weights and state transition probability matrix
    gen_weights = np.array([[[6, 1]], [[2, -3]], [[2, 3]]])
    gen_log_trans_mat = np.log(np.array([[[0.98, 0.01, 0.01], [0.05, 0.92, 0.03], [0.03, 0.03, 0.94]]]))
    # initialize a standard glmhmm with starting weights and transition matrix

    true_glmhmm = make_standard_hmm(gen_weights, gen_log_trans_mat)
    inpts=generate_inputs(ntrials, num_sess)
    true_ll, true_latents, true_choices = true_ll_model(ntrials, num_sess)
    psy_track_data = convert_data_for_psytrack(inpts, true_choices) # convert data generated with glmhmm into psytrack format
    # initialize new glm_hmm
    new_glmhmm = ssm.HMM(num_states, obs_dim, input_dim, observations="input_driven_obs", 
                            observation_kwargs=dict(C=num_categories), transitions="standard")
    fit_ll = fit_glm_hmm(new_glmhmm) # fit newly created glm-hmm
    hyp, evd, wMode, hess_info = fit_psytrack(psy_track_data)

